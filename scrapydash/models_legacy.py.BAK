# coding: utf-8
import os
from pprint import pformat
import time
from datetime import datetime

from sqlalchemy import Column, Integer, String, Float, DateTime, Text, ForeignKey, UniqueConstraint
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, sessionmaker
from sqlalchemy import create_engine

from .__version__ import __version__

# Legacy Flask-SQLAlchemy compatibility classes
class LegacySQLAlchemy:
    """Legacy SQLAlchemy wrapper for backward compatibility"""
    def __init__(self):
        self.Model = declarative_base()
        self.session = None
        self.engine = None
        
    def create_all(self):
        """Create all tables - legacy compatibility"""
        try:
            if self.engine:
                self.Model.metadata.create_all(bind=self.engine)
        except Exception as e:
            print(f"Warning: Could not create tables: {e}")
    
    def init_app(self, app):
        """Initialize with app - legacy compatibility"""
        pass

class LegacyQuery:
    """Legacy query interface for backward compatibility"""
    def __init__(self, model_class):
        self.model_class = model_class
        
    def filter_by(self, **kwargs):
        """Mock filter_by method"""
        return self
        
    def first(self):
        """Mock first method"""
        return None
        
    def all(self):
        """Mock all method"""
        return []

# Create legacy db instance
db = LegacySQLAlchemy()

# Base model class
Base = declarative_base()

class Metadata(Base):
    __tablename__ = 'metadata'
    
    id = Column(Integer, primary_key=True)
    version = Column(String(50), nullable=False, unique=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Add query property for legacy compatibility
    @classmethod
    def query(cls):
        return LegacyQuery(cls)
    
    def __repr__(self):
        return f'<Metadata {self.version}>'

class Task(Base):
    __tablename__ = 'task'
    
    id = Column(Integer, primary_key=True)
    node = Column(Integer, nullable=False)
    project = Column(String(200), nullable=False)
    version = Column(String(200))
    spider = Column(String(200), nullable=False)
    jobid = Column(String(200))
    settings = Column(Text)
    selected_nodes = Column(Text)
    create_time = Column(DateTime, default=datetime.utcnow)
    update_time = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    results = relationship("TaskResult", back_populates="task")
    job_results = relationship("TaskJobResult", back_populates="task")
    
    @classmethod
    def query(cls):
        return LegacyQuery(cls)
    
    def __repr__(self):
        return f'<Task {self.id}: {self.project}/{self.spider}>'

class TaskResult(Base):
    __tablename__ = 'taskresult'
    
    id = Column(Integer, primary_key=True)
    task_id = Column(Integer, ForeignKey('task.id'), nullable=False)
    node = Column(Integer, nullable=False)
    status = Column(String(50))
    result = Column(Text)
    create_time = Column(DateTime, default=datetime.utcnow)
    update_time = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    task = relationship("Task", back_populates="results")
    
    @classmethod
    def query(cls):
        return LegacyQuery(cls)
    
    def __repr__(self):
        return f'<TaskResult {self.id}: task={self.task_id}, node={self.node}>'

class TaskJobResult(Base):
    __tablename__ = 'taskjobresult'
    
    id = Column(Integer, primary_key=True)
    task_id = Column(Integer, ForeignKey('task.id'), nullable=False)
    node = Column(Integer, nullable=False)
    jobid = Column(String(200))
    status = Column(String(50))
    result = Column(Text)
    create_time = Column(DateTime, default=datetime.utcnow)
    update_time = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    task = relationship("Task", back_populates="job_results")
    
    @classmethod
    def query(cls):
        return LegacyQuery(cls)
    
    def __repr__(self):
        return f'<TaskJobResult {self.id}: task={self.task_id}, jobid={self.jobid}>'

# Dynamic Job table creation function
def create_job_table(node_id: int):
    """Create a dynamic Job table for a specific node"""
    from sqlalchemy import Table, MetaData
    
    table_name = f'job_{node_id}'
    
    job_table = Table(
        table_name, Base.metadata,
        Column('id', Integer, primary_key=True),
        Column('project', String(200), nullable=False),
        Column('spider', String(200), nullable=False),
        Column('jobid', String(200), nullable=False, unique=True),
        Column('start_time', DateTime),
        Column('end_time', DateTime),
        Column('status', String(50)),
        Column('log_url', String(500)),
        Column('items_url', String(500)),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('update_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
        extend_existing=True
    )
    
    return job_table

# Initialize database with error handling
try:
    # Try to create database engine if not exists
    if not hasattr(db, 'engine') or db.engine is None:
        db.engine = create_engine('sqlite:///scrapydweb.db', echo=False)
        db.session = sessionmaker(bind=db.engine)()
        
    # Create tables with error handling
    db.create_all()
except Exception as e:
    print(f"Warning: Database initialization failed: {e}")
    # Continue without database for now
